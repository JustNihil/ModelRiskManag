<?xml version="1.0" encoding="UTF-8"?>
<!--
*************************************************
	         AnyLogic Project File
*************************************************
-->
<AnyLogicWorkspace WorkspaceVersion="1.9" AnyLogicVersion="8.9.1.202408021040" AlpVersion="8.9.1">
<Model>
	<Id>1740651593999</Id>
	<Name><![CDATA[Model]]></Name>
	<EngineVersion>6</EngineVersion>
	<JavaPackageName><![CDATA[model]]></JavaPackageName>
	<ModelTimeUnit><![CDATA[Second]]></ModelTimeUnit>
	
	<Folders>
		
	</Folders>
	<ActiveObjectClasses>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1740651594002</Id>
			<Name><![CDATA[Main]]></Name>
			<AdditionalClassCode><![CDATA[ServerManager serverManager;


    @Override
    public void onStartup() {
        traceln("Initializing server...");
        serverManager = new ServerManager();


        serverManager.startServer();
    }
 
]]></AdditionalClassCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1740651594008</Id>
				<Name><![CDATA[1740651594008]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Параметр настройки:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1740729600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1740651594005</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1740651594009</CurrentLevel>
			<ConnectionsId>1740651594003</ConnectionsId>
			<AgentLinks>
				<AgentLink>
					<Id>1740651594003</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Presentation>
				<Level>
					<Id>1740651594009</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>


				</Level>
			</Presentation>

		</ActiveObjectClass>
	</ActiveObjectClasses>
	<DifferentialEquationsMethod>EULER</DifferentialEquationsMethod>
	<MixedEquationsMethod>RK45_NEWTON</MixedEquationsMethod>
	<AlgebraicEquationsMethod>MODIFIED_NEWTON</AlgebraicEquationsMethod>
	<AbsoluteAccuracy>1.0E-5</AbsoluteAccuracy>
	<FixedTimeStep>0.001</FixedTimeStep>
	<RelativeAccuracy>1.0E-5</RelativeAccuracy>
	<TimeAccuracy>1.0E-5</TimeAccuracy>
	<Frame>
		<Width>1000</Width>
		<Height>600</Height>
	</Frame>
	<Database>
		<Logging>false</Logging>
		<AutoExport>false</AutoExport>
		<ShutdownCompact>false</ShutdownCompact>
		<ImportSettings>
		</ImportSettings>
		<ExportSettings>
		</ExportSettings>
	</Database>

	<RunConfiguration ActiveObjectClassId="1740651594002">
		<Id>1740651594014</Id>
		<Name><![CDATA[RunConfiguration]]></Name>
		<MaximumMemory>512</MaximumMemory>
		<ModelTimeProperties>
			<StopOption><![CDATA[Stop at specified time]]></StopOption>
			<InitialDate><![CDATA[1740614400000]]></InitialDate>	
			<InitialTime><![CDATA[0.0]]></InitialTime>	
			<FinalDate><![CDATA[1743033600000]]></FinalDate>	
			<FinalTime><![CDATA[100.0]]></FinalTime>	
		</ModelTimeProperties>
		<AnimationProperties>
			<StopNever>true</StopNever>
			<ExecutionMode>realTimeScaled</ExecutionMode>
			<RealTimeScale>1.0</RealTimeScale>
			<EnableZoomAndPanning>true</EnableZoomAndPanning>
			<EnableDeveloperPanel>false</EnableDeveloperPanel>
			<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
		</AnimationProperties>
		<Inputs>		
		</Inputs>
		<Outputs>
		</Outputs>
	</RunConfiguration>
	<Experiments>	
		<!--   =========   Simulation Experiment   ========  -->
		<SimulationExperiment ActiveObjectClassId="1740651594002">
			<Id>1740651594011</Id>
			<Name><![CDATA[Simulation]]></Name>
			<CommandLineArguments><![CDATA[]]></CommandLineArguments>
			<MaximumMemory>512</MaximumMemory>
			<RandomNumberGenerationType>fixedSeed</RandomNumberGenerationType>
			<CustomGeneratorCode>new Random()</CustomGeneratorCode>
			<SeedValue>1</SeedValue>
			<SelectionModeForSimultaneousEvents>LIFO</SelectionModeForSimultaneousEvents>
			<VmArgs><![CDATA[]]></VmArgs>
			<LoadRootFromSnapshot>false</LoadRootFromSnapshot>

			<Presentation>
				<Text>
					<Id>1740651594013</Id>
					<Name><![CDATA[text]]></Name>
					<X>50</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12490271</Color>
					<Text><![CDATA[Model]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>24</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

			<Parameters>			
			</Parameters>			
			<PresentationProperties>
				<EnableZoomAndPanning>true</EnableZoomAndPanning>
				<ExecutionMode><![CDATA[realTimeScaled]]></ExecutionMode>
				<Title><![CDATA[Model : Simulation]]></Title>	
				<EnableDeveloperPanel>true</EnableDeveloperPanel>
				<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
				<RealTimeScale>1.0</RealTimeScale>
			</PresentationProperties>
			<ModelTimeProperties>
				<StopOption><![CDATA[Never]]></StopOption>
				<InitialDate><![CDATA[1740614400000]]></InitialDate>	
				<InitialTime><![CDATA[0.0]]></InitialTime>	
				<FinalDate><![CDATA[1743033600000]]></FinalDate>	
				<FinalTime><![CDATA[100.0]]></FinalTime>	
			</ModelTimeProperties>
			<BypassInitialScreen>true</BypassInitialScreen>
		</SimulationExperiment>	
	</Experiments>
	<JavaClasses>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1740651656410</Id>
			<Name><![CDATA[ServerManager]]></Name>
			<Text><![CDATA[import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.servlet.ServletContextHandler;
import org.eclipse.jetty.servlet.ServletHolder;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.io.*;
import java.sql.*; // Используем стандартный Java SQL API
import java.util.*;
import java.util.stream.Collectors;

public class ServerManager {
    ArrayList<Stage> stages = new ArrayList<>();
    ArrayList<Risk> risks = new ArrayList<>();
    double totalTime, totalCost, mitigationBudget;
    String mitigationStrategy;
    List<Double> timeResults = new ArrayList<>();
    List<Double> costResults = new ArrayList<>();
    double time90thPercentile, cost90thPercentile;
    double timeThreshold = 150, costThreshold = 75000;
    double timeExceedProbability, costExceedProbability;
    double timeStdDev, costStdDev;
    double timeConfidenceLower, timeConfidenceUpper;
    double costConfidenceLower, costConfidenceUpper;
    double targetTime = 120, targetCost = 60000;
    double timeTargetProbability, costTargetProbability;
    List<Risk> criticalRisks = new ArrayList<>();
    List<Stage> criticalStages = new ArrayList<>();

    private static final String DB_URL = "jdbc:postgresql://localhost:5435/risk_db";
    private static final String DB_USER = "risk_user";
    private static final String DB_PASSWORD = "235521";
    private static final String PYTHON_PATH = "C:/Users/dmitr/AppData/Local/Programs/Python/Python313/python.exe";
    private static final String PYTHON_SERVER_DIR = "C:/Users/dmitr/Models";
    private static final String SUPERSET_CLI_PATH = "C:/Users/dmitr/Models/superset_cli.py";
    private java.sql.Connection dbConnection; // Используем java.sql.Connection

    class Stage {
        String name;
        double duration, cost;
        double durationOptimistic, durationPessimistic;
        double costOptimistic, costPessimistic;

        Stage(String name, double duration, double cost) {
            this.name = name;
            this.duration = duration;
            this.cost = cost;
            this.durationOptimistic = duration * 0.9;
            this.durationPessimistic = duration * 1.1;
            this.costOptimistic = cost * 0.9;
            this.costPessimistic = cost * 1.1;
        }
    }

    static class Risk {
        String name;
        double probability;
        double impactTime, impactCost;
        boolean mitigated;
        String strategy, category;
        double priority;
        double impactTimeOptimistic, impactTimePessimistic;
        double impactCostOptimistic, impactCostPessimistic;

        Risk(String name, double probability, double impactTime, double impactCost, String strategy, String category) {
            this.name = name;
            this.probability = probability;
            this.impactTime = impactTime;
            this.impactCost = impactCost;
            this.mitigated = false;
            this.strategy = strategy != null && !strategy.isEmpty() ? strategy : "Ignore";
            this.category = category != null ? category : "Не указано";
            this.priority = probability * (impactTime + impactCost / 1000);
            this.impactTimeOptimistic = impactTime * 0.8;
            this.impactTimePessimistic = impactTime * 1.2;
            this.impactCostOptimistic = impactCost * 0.8;
            this.impactCostPessimistic = impactCost * 1.2;
        }
    }

    class Mitigation {
        String strategy;
        double budget;
    }

    class ModelData {
        List<Stage> stages;
        List<Risk> risks;
        double timeThreshold, costThreshold;
        double targetTime, targetCost;
    }

    private static final List<Risk> typicalRisks = Arrays.asList(
        new Risk("Задержка в разработке", 0.4, 10, 5000, "Mitigate", "Технические"),
        new Risk("Отсутствие сотрудников", 0.3, 30, 10000, "Eliminate", "Организационные"),
        new Risk("Задержка поставки оборудования", 0.3, 15, 7000, "Mitigate", "Внешние"),
        new Risk("Неправильное планирование", 0.5, 20, 15000, "Mitigate", "Организационные"),
        new Risk("Кибератака", 0.2, 15, 20000, "Eliminate", "Технические")
    );

    public ServerManager() {
        try {
            // Загружаем драйвер PostgreSQL
            Class.forName("org.postgresql.Driver");
            // Используем java.sql.DriverManager для подключения
            dbConnection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
            System.out.println("Connected to PostgreSQL successfully using java.sql.DriverManager.");
        } catch (ClassNotFoundException e) {
            System.err.println("PostgreSQL JDBC Driver not found: " + e.getMessage());
            e.printStackTrace();
        } catch (SQLException e) {
            System.err.println("Error connecting to PostgreSQL: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private String runPythonCommand(String[] command) throws IOException, InterruptedException {
        System.out.println("Запуск команды: " + String.join(" ", command));
        ProcessBuilder pb = new ProcessBuilder(command);
        pb.directory(new java.io.File(PYTHON_SERVER_DIR));
        pb.redirectErrorStream(true);
        Process process = pb.start();
        String output = new java.io.BufferedReader(
            new java.io.InputStreamReader(process.getInputStream())
        ).lines().collect(Collectors.joining("\n"));
        String error = new java.io.BufferedReader(
            new java.io.InputStreamReader(process.getErrorStream())
        ).lines().collect(Collectors.joining("\n"));
        int exitCode = process.waitFor();
        System.out.println("Вывод Python: " + output);
        System.out.println("Ошибка Python (stderr): " + error);
        if (exitCode != 0) {
            throw new IOException("Python script failed with exit code " + exitCode + ": " + error + " | Output: " + output);
        }
        return output;
    }

    private Process startPythonServer() throws IOException {
        ProcessBuilder pb = new ProcessBuilder(PYTHON_PATH, "-m", "http.server", "8000");
        pb.directory(new java.io.File(PYTHON_SERVER_DIR));
        pb.redirectErrorStream(true);
        Process process = pb.start();

        new Thread(() -> {
            try (java.io.BufferedReader reader = new java.io.BufferedReader(
                    new java.io.InputStreamReader(process.getInputStream()))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println("Python Server: " + line);
                }
            } catch (IOException e) {
                System.err.println("Error reading Python server output: " + e.getMessage());
            }
        }).start();

        System.out.println("Python HTTP Server started on port 8000 in directory: " + PYTHON_SERVER_DIR);
        return process;
    }

    public void startServer() {
        Process pythonProcess = null;
        try {
            pythonProcess = startPythonServer();

            Server server = new Server(8089);
            ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
            context.setContextPath("/");
            server.setHandler(context);

            context.addServlet(new ServletHolder(new CreateModelServlet()), "/create");
            context.addServlet(new ServletHolder(new AddRiskServlet()), "/addRisk");
            context.addServlet(new ServletHolder(new SetMitigationServlet()), "/mitigation");
            context.addServlet(new ServletHolder(new RunServlet()), "/run");
            context.addServlet(new ServletHolder(new ResultsServlet()), "/results");
            context.addServlet(new ServletHolder(new GetTypicalRisksServlet()), "/typicalRisks");
            context.addServlet(new ServletHolder(new ExportDashboardServlet()), "/exportDashboard");
            context.addServlet(new ServletHolder(new RiskLogsServlet()), "/riskLogs");

            server.start();
            System.out.println("Jetty Server started on port 8089");
            server.join();
        } catch (Exception e) {
            System.err.println("Error starting servers: " + e.getMessage());
            e.printStackTrace();
            if (pythonProcess != null) {
                pythonProcess.destroy();
            }
        }
    }

    class CreateModelServlet extends HttpServlet {
        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            try {
                String json = req.getReader().lines().reduce("", (a, b) -> a + b);
                System.out.println("Полученный JSON: " + json);
                Gson gson = new Gson();
                ModelData modelData = gson.fromJson(json, ModelData.class);
                if (modelData != null && modelData.stages != null && !modelData.stages.isEmpty()) {
                    stages.clear();
                    risks.clear();
                    stages.addAll(modelData.stages);
                    if (modelData.risks != null) {
                        risks.addAll(modelData.risks);
                    }
                    timeThreshold = modelData.timeThreshold != 0 ? modelData.timeThreshold : 150;
                    costThreshold = modelData.costThreshold != 0 ? modelData.costThreshold : 75000;
                    targetTime = modelData.targetTime != 0 ? modelData.targetTime : 120;
                    targetCost = modelData.targetCost != 0 ? modelData.targetCost : 60000;
                    runPertSimulation();
                    uploadToPostgreSQL();
                    resp.getWriter().write("Модель создана с " + stages.size() + " этапами и " + risks.size() + " рисками");
                } else {
                    resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Некорректные данные этапов");
                }
            } catch (Exception e) {
                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Ошибка создания модели: " + e.getMessage());
            }
        }

        @Override
        protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            resp.setStatus(HttpServletResponse.SC_OK);
        }
    }

    class AddRiskServlet extends HttpServlet {
        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            try {
                String json = req.getReader().lines().reduce("", (a, b) -> a + b);
                Gson gson = new Gson();
                Risk risk = gson.fromJson(json, Risk.class);
                if (risk != null && risk.name != null && !risk.name.isEmpty()) {
                    // Проверяем, существует ли риск с таким именем
                    if (risks.stream().noneMatch(r -> r.name.equals(risk.name))) {
                        risks.add(risk);
                        uploadToPostgreSQL();
                        logRiskAction(risk.name, "Добавлен", "Добавлен риск с приоритетом " + risk.priority);
                        resp.getWriter().write("Риск добавлен: " + risk.name);
                    } else {
                        resp.getWriter().write("Риск с именем " + risk.name + " уже существует.");
                        System.out.println("Риск с именем " + risk.name + " уже существует, пропускаем добавление.");
                    }
                } else {
                    resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Некорректные данные риска");
                }
            } catch (Exception e) {
                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Ошибка добавления риска: " + e.getMessage());
            }
        }

        @Override
        protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            resp.setStatus(HttpServletResponse.SC_OK);
        }
    }

    class SetMitigationServlet extends HttpServlet {
        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            try {
                String json = req.getReader().lines().reduce("", (a, b) -> a + b);
                Gson gson = new Gson();
                Mitigation mitigation = gson.fromJson(json, Mitigation.class);
                if (mitigation != null && mitigation.strategy != null && !mitigation.strategy.isEmpty()) {
                    mitigationStrategy = mitigation.strategy;
                    mitigationBudget = mitigation.budget;
                    runPertSimulation(); // Добавляем вызов симуляции
                    uploadToPostgreSQL();
                    resp.getWriter().write("Стратегия установлена: " + mitigationStrategy);
                } else {
                    resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Некорректные данные стратегии");
                }
            } catch (Exception e) {
                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Ошибка установки стратегии: " + e.getMessage());
            }
        }

        @Override
        protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            resp.setStatus(HttpServletResponse.SC_OK);
        }
    }

    class RunServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            try {
                runPertSimulation();
                double mitigationCost = 0;
                for (Risk risk : risks) {
                    if (Math.random() < risk.probability && !risk.mitigated) {
                        if ("Mitigate".equals(risk.strategy) && mitigationBudget >= 500) {
                            totalTime += risk.impactTime * 0.5;
                            totalCost += risk.impactCost * 0.5;
                            mitigationCost += 500;
                            risk.mitigated = true;
                            mitigationBudget -= 500;
                            logRiskAction(risk.name, "Смягчён", "Риск смягчён с помощью стратегии Mitigate");
                        } else if ("Eliminate".equals(risk.strategy) && mitigationBudget >= 2000) {
                            totalTime += 5;
                            totalCost += risk.impactCost;
                            mitigationCost += 2000;
                            risk.mitigated = true;
                            mitigationBudget -= 2000;
                            logRiskAction(risk.name, "Устранён", "Риск устранён с помощью стратегии Eliminate");
                        } else {
                            totalTime += risk.impactTime;
                            totalCost += risk.impactCost;
                            logRiskAction(risk.name, "Произошёл", "Риск произошёл без смягчения");
                        }
                    }
                }
                totalCost += mitigationCost;
                uploadToPostgreSQL();
                resp.getWriter().write("Симуляция завершена. Стоимость управления: $" + mitigationCost);
            } catch (Exception e) {
                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Ошибка симуляции: " + e.getMessage());
            }
        }

        @Override
        protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            resp.setStatus(HttpServletResponse.SC_OK);
        }
    }

    class ResultsServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            try {
                Gson gson = new Gson();
                String json = gson.toJson(new Results(totalTime, totalCost, risks));
                resp.setContentType("application/json");
                resp.getWriter().write(json);
            } catch (Exception e) {
                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Ошибка получения результатов: " + e.getMessage());
            }
        }

        @Override
        protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            resp.setStatus(HttpServletResponse.SC_OK);
        }
    }

    class GetTypicalRisksServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            try {
                Gson gson = new Gson();
                String json = gson.toJson(typicalRisks);
                resp.setContentType("application/json");
                resp.getWriter().write(json);
            } catch (Exception e) {
                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Ошибка получения типичных рисков: " + e.getMessage());
            }
        }

        @Override
        protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            resp.setStatus(HttpServletResponse.SC_OK);
        }
    }

    class ExportDashboardServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            try {
                System.out.println("Начинаем экспорт метрик...");
                String[] metricsCmd = {PYTHON_PATH, SUPERSET_CLI_PATH, "export_metrics"};
                String metricsJson = runPythonCommand(metricsCmd);
                System.out.println("Метрики экспортированы: " + metricsJson);

                System.out.println("Начинаем экспорт рисков...");
                String[] risksCmd = {PYTHON_PATH, SUPERSET_CLI_PATH, "export_risks"};
                String risksJson = runPythonCommand(risksCmd);
                System.out.println("Риски экспортированы: " + risksJson);

                Gson gson = new Gson();
                Object metrics = gson.fromJson(metricsJson, Object.class);
                List<Risk> risksData = gson.fromJson(risksJson, new TypeToken<List<Risk>>(){}.getType());

                if (metrics == null) {
                    throw new Exception("Ошибка экспорта метрик: результат null");
                }
                if (metrics instanceof java.util.Map && ((java.util.Map<?, ?>) metrics).containsKey("error")) {
                    throw new Exception("Ошибка экспорта метрик: " + ((java.util.Map<?, ?>) metrics).get("error"));
                }
                if (risksData == null) {
                    throw new Exception("Ошибка экспорта рисков: результат null");
                }
                if (risksData instanceof java.util.Map && ((java.util.Map<?, ?>) risksData).containsKey("error")) {
                    throw new Exception("Ошибка экспорта рисков: " + ((java.util.Map<?, ?>) risksData).get("error"));
                }

                // Формируем dashboardData как объект, а затем сериализуем его в JSON
                Map<String, Object> dashboardDataMap = new HashMap<>();
                dashboardDataMap.put("timeResults", timeResults);
                dashboardDataMap.put("costResults", costResults);
                dashboardDataMap.put("time90thPercentile", time90thPercentile);
                dashboardDataMap.put("cost90thPercentile", cost90thPercentile);
                dashboardDataMap.put("timeThreshold", timeThreshold);
                dashboardDataMap.put("costThreshold", costThreshold);
                dashboardDataMap.put("timeExceedProbability", timeExceedProbability);
                dashboardDataMap.put("costExceedProbability", costExceedProbability);
                dashboardDataMap.put("timeStdDev", timeStdDev);
                dashboardDataMap.put("costStdDev", costStdDev);
                dashboardDataMap.put("timeConfidenceLower", timeConfidenceLower);
                dashboardDataMap.put("timeConfidenceUpper", timeConfidenceUpper);
                dashboardDataMap.put("costConfidenceLower", costConfidenceLower);
                dashboardDataMap.put("costConfidenceUpper", costConfidenceUpper);
                dashboardDataMap.put("targetTime", targetTime);
                dashboardDataMap.put("targetCost", targetCost);
                dashboardDataMap.put("timeTargetProbability", timeTargetProbability);
                dashboardDataMap.put("costTargetProbability", costTargetProbability);
                dashboardDataMap.put("criticalRisks", criticalRisks);
                dashboardDataMap.put("criticalStages", criticalStages);

                String dashboardData = gson.toJson(dashboardDataMap); // Сериализуем в корректный JSON

                resp.setContentType("application/json");
                resp.getWriter().write(gson.toJson(new DashboardData(metrics, risksData, dashboardData)));
            } catch (Exception e) {
                System.err.println("Ошибка в ExportDashboardServlet: " + e.getMessage());
                e.printStackTrace();
                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Ошибка экспорта: " + e.getMessage());
            }
        }

        @Override
        protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            resp.setStatus(HttpServletResponse.SC_OK);
        }
    }

    class RiskLogsServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            Connection localConnection = null;
            try {
                localConnection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
                java.sql.Statement stmt = localConnection.createStatement();
                java.sql.ResultSet rs = stmt.executeQuery("SELECT risk_name, action, timestamp, details FROM risk_logs ORDER BY timestamp DESC");

                List<Map<String, Object>> logs = new ArrayList<>();
                while (rs.next()) {
                    Map<String, Object> log = new HashMap<>();
                    log.put("risk_name", rs.getString("risk_name"));
                    log.put("action", rs.getString("action"));
                    log.put("timestamp", rs.getString("timestamp"));
                    log.put("details", rs.getString("details"));
                    logs.add(log);
                }

                rs.close();
                stmt.close();

                Gson gson = new Gson();
                String response = gson.toJson(logs);
                resp.setContentType("application/json");
                resp.getWriter().write(response);
            } catch (SQLException e) {
                System.err.println("Ошибка в RiskLogsServlet: " + e.getMessage());
                e.printStackTrace();
                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Ошибка получения логов: " + e.getMessage());
            } finally {
                if (localConnection != null) {
                    try {
                        localConnection.close();
                    } catch (SQLException e) {
                        System.err.println("Ошибка при закрытии соединения в RiskLogsServlet: " + e.getMessage());
                    }
                }
            }
        }

        @Override
        protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            addCorsHeaders(resp);
            resp.setStatus(HttpServletResponse.SC_OK);
        }
    }

    private void addCorsHeaders(HttpServletResponse resp) {
        resp.setHeader("Access-Control-Allow-Origin", "http://localhost:8000");
        resp.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        resp.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization, Accept, Accept-Language, Content-Language, X-Requested-With");
        resp.setHeader("Access-Control-Allow-Credentials", "true");
        resp.setHeader("Access-Control-Max-Age", "86400");
    }

    class Results {
        double totalTime, totalCost;
        List<Risk> risks;
        Results(double totalTime, double totalCost, List<Risk> risks) {
            this.totalTime = totalTime;
            this.totalCost = totalCost;
            this.risks = risks;
        }
    }

    class DashboardData {
        Object metrics;
        List<Risk> risks;
        String dashboardData;
        DashboardData(Object metrics, List<Risk> risks, String dashboardData) {
            this.metrics = metrics;
            this.risks = risks;
            this.dashboardData = dashboardData;
        }
    }

    private void runPertSimulation() {
        timeResults.clear();
        costResults.clear();
        criticalRisks.clear();
        criticalStages.clear();

        double totalTimeVariance = 0;
        double totalCostVariance = 0;

        for (Stage stage : stages) {
            double stageTime = (stage.durationOptimistic + 4 * stage.duration + stage.durationPessimistic) / 6;
            double stageTimeVariance = Math.pow((stage.durationPessimistic - stage.durationOptimistic) / 6, 2);
            totalTimeVariance += stageTimeVariance;

            double stageCost = (stage.costOptimistic + 4 * stage.cost + stage.costPessimistic) / 6;
            double stageCostVariance = Math.pow((stage.costPessimistic - stage.costOptimistic) / 6, 2);
            totalCostVariance += stageCostVariance;

            if (stageTimeVariance > totalTimeVariance * 0.2 || stageCostVariance > totalCostVariance * 0.2) {
                criticalStages.add(stage);
            }
        }

        // Пересчитываем приоритеты рисков
        for (Risk risk : risks) {
            risk.priority = risk.probability * (risk.impactTime + risk.impactCost / 1000); // Обновляем приоритет
            if (!risk.mitigated) {
                double expectedImpactTime = risk.probability * (risk.impactTimeOptimistic + 4 * risk.impactTime + risk.impactTimePessimistic) / 6;
                double expectedImpactCost = risk.probability * (risk.impactCostOptimistic + 4 * risk.impactCost + risk.impactCostPessimistic) / 6;

                double impactTimeVariance = Math.pow((risk.impactTimePessimistic - risk.impactTimeOptimistic) / 6, 2) * risk.probability;
                double impactCostVariance = Math.pow((risk.impactCostPessimistic - risk.impactCostOptimistic) / 6, 2) * risk.probability;

                totalTimeVariance += impactTimeVariance;
                totalCostVariance += impactCostVariance;

                if (impactTimeVariance > totalTimeVariance * 0.2 || impactCostVariance > totalCostVariance * 0.2) {
                    criticalRisks.add(risk);
                }
            }
        }

        totalTime = stages.stream().mapToDouble(s -> (s.durationOptimistic + 4 * s.duration + s.durationPessimistic) / 6).sum();
        totalCost = stages.stream().mapToDouble(s -> (s.costOptimistic + 4 * s.cost + s.costPessimistic) / 6).sum();

        for (Risk risk : risks) {
            if (!risk.mitigated) {
                totalTime += risk.probability * (risk.impactTimeOptimistic + 4 * risk.impactTime + risk.impactTimePessimistic) / 6;
                totalCost += risk.probability * (risk.impactCostOptimistic + 4 * risk.impactCost + risk.impactCostPessimistic) / 6;
            }
        }

        timeStdDev = Math.sqrt(totalTimeVariance);
        costStdDev = Math.sqrt(totalCostVariance);

        timeConfidenceLower = totalTime - 1.96 * timeStdDev;
        timeConfidenceUpper = totalTime + 1.96 * timeStdDev;
        costConfidenceLower = totalCost - 1.96 * costStdDev;
        costConfidenceUpper = totalCost + 1.96 * costStdDev;

        timeTargetProbability = 0.5 * (1 + erf((targetTime - totalTime) / (timeStdDev * Math.sqrt(2))));
        costTargetProbability = 0.5 * (1 + erf((targetCost - totalCost) / (costStdDev * Math.sqrt(2))));

        for (int i = 0; i < 1000; i++) {
            double simTime = normal(totalTime, timeStdDev);
            double simCost = normal(totalCost, costStdDev);
            timeResults.add(simTime);
            costResults.add(simCost);
        }

        timeResults.sort(Double::compareTo);
        costResults.sort(Double::compareTo);

        time90thPercentile = timeResults.get((int) (1000 * 0.9));
        cost90thPercentile = costResults.get((int) (1000 * 0.9));

        timeExceedProbability = timeResults.stream().filter(t -> t > timeThreshold).count() / 1000.0;
        costExceedProbability = costResults.stream().filter(c -> c > costThreshold).count() / 1000.0;

        for (Risk risk : risks) {
            if (risk.priority > 10 && !risk.mitigated) {
                risk.strategy = "Mitigate";
                risk.mitigated = true;
                logRiskAction(risk.name, "Автосмягчение", "Риск с высоким приоритетом автоматически смягчён");
            } else if (risk.priority > 5 && !risk.mitigated) {
                risk.strategy = "Monitor";
            }
        }
    }

    private double erf(double z) {
        double t = 1.0 / (1.0 + 0.5 * Math.abs(z));
        double ans = 1 - t * Math.exp(-z * z - 1.26551223 +
            t * (1.00002368 + t * (0.37409196 + t * (0.09678418 +
            t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 +
            t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));
        return z >= 0 ? ans : -ans;
    }

    private double normal(double mean, double stdDev) {
        Random random = new Random();
        return mean + stdDev * random.nextGaussian();
    }

    // Перегруженный метод logRiskAction без Connection
    private void logRiskAction(String riskName, String action, String details) {
        Connection localConnection = null;
        try {
            localConnection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
            logRiskAction(riskName, action, details, localConnection);
        } catch (SQLException e) {
            System.err.println("Ошибка при создании соединения в logRiskAction: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (localConnection != null) {
                try {
                    localConnection.close();
                } catch (SQLException e) {
                    System.err.println("Ошибка при закрытии соединения в logRiskAction: " + e.getMessage());
                }
            }
        }
    }

    // Оригинальный метод logRiskAction с Connection
    private void logRiskAction(String riskName, String action, String details, Connection connection) {
        try {
            java.sql.PreparedStatement logStmt = connection.prepareStatement(
                "INSERT INTO risk_logs (risk_name, action, details) VALUES (?, ?, ?)"
            );
            logStmt.setString(1, riskName);
            logStmt.setString(2, action);
            logStmt.setString(3, details);
            logStmt.executeUpdate();
            System.out.println("Действие с риском записано в лог: " + riskName + " - " + action);
        } catch (SQLException e) {
            System.err.println("Error logging risk action: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void uploadToPostgreSQL() {
        Connection localConnection = null;
        boolean autoCommitWasEnabled = true;
        try {
            // Создаём новое соединение для этого вызова
            localConnection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
            System.out.println("Новое подключение к PostgreSQL создано для uploadToPostgreSQL.");

            // Логируем начальное состояние autoCommit
            autoCommitWasEnabled = localConnection.getAutoCommit();
            System.out.println("Начальное состояние autoCommit: " + autoCommitWasEnabled);

            // Отключаем autoCommit
            localConnection.setAutoCommit(false);
            System.out.println("autoCommit отключён: " + localConnection.getAutoCommit());

            // Удаляем старые данные из project_metrics
            java.sql.PreparedStatement deleteMetricsStmt = localConnection.prepareStatement(
                "DELETE FROM project_metrics"
            );
            deleteMetricsStmt.executeUpdate();
            System.out.println("Старые данные из project_metrics удалены.");

            // Сохраняем новые метрики
            java.sql.PreparedStatement metricsStmt = localConnection.prepareStatement(
                "INSERT INTO project_metrics (total_time, total_cost, mitigation_strategy, mitigation_budget, time_results, cost_results, time_90th_percentile, cost_90th_percentile, time_threshold, cost_threshold, time_exceed_probability, cost_exceed_probability, time_std_dev, cost_std_dev, time_confidence_lower, time_confidence_upper, cost_confidence_lower, cost_confidence_upper, target_time, target_cost, time_target_probability, cost_target_probability) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
            );
            metricsStmt.setDouble(1, totalTime);
            metricsStmt.setDouble(2, totalCost);
            metricsStmt.setString(3, mitigationStrategy != null ? mitigationStrategy : "N/A");
            metricsStmt.setDouble(4, mitigationBudget);
            metricsStmt.setArray(5, localConnection.createArrayOf("float8", timeResults.toArray()));
            metricsStmt.setArray(6, localConnection.createArrayOf("float8", costResults.toArray()));
            metricsStmt.setDouble(7, time90thPercentile);
            metricsStmt.setDouble(8, cost90thPercentile);
            metricsStmt.setDouble(9, timeThreshold);
            metricsStmt.setDouble(10, costThreshold);
            metricsStmt.setDouble(11, timeExceedProbability);
            metricsStmt.setDouble(12, costExceedProbability);
            metricsStmt.setDouble(13, timeStdDev);
            metricsStmt.setDouble(14, costStdDev);
            metricsStmt.setDouble(15, timeConfidenceLower);
            metricsStmt.setDouble(16, timeConfidenceUpper);
            metricsStmt.setDouble(17, costConfidenceLower);
            metricsStmt.setDouble(18, costConfidenceUpper);
            metricsStmt.setDouble(19, targetTime);
            metricsStmt.setDouble(20, targetCost);
            metricsStmt.setDouble(21, timeTargetProbability);
            metricsStmt.setDouble(22, costTargetProbability);
            int rowsAffected = metricsStmt.executeUpdate();
            System.out.println("Новые метрики сохранены, строк затронуто: " + rowsAffected);

            // Удаляем старые данные из stages
            java.sql.PreparedStatement deleteStagesStmt = localConnection.prepareStatement(
                "DELETE FROM stages"
            );
            deleteStagesStmt.executeUpdate();
            System.out.println("Старые данные из stages удалены.");

            // Сохраняем новые этапы
            java.sql.PreparedStatement stageStmt = localConnection.prepareStatement(
                "INSERT INTO stages (name, duration, cost) VALUES (?, ?, ?)"
            );
            for (Stage stage : stages) {
                stageStmt.setString(1, stage.name);
                stageStmt.setDouble(2, stage.duration);
                stageStmt.setDouble(3, stage.cost);
                stageStmt.executeUpdate();
            }
            System.out.println("Новые этапы сохранены.");

            // Удаляем старые данные из risks
            java.sql.PreparedStatement deleteRisksStmt = localConnection.prepareStatement(
                "DELETE FROM risks"
            );
            deleteRisksStmt.executeUpdate();
            System.out.println("Старые данные из risks удалены.");

            // Сохраняем новые риски
            java.sql.PreparedStatement riskStmt = localConnection.prepareStatement(
                "INSERT INTO risks (name, probability, impact_time, impact_cost, mitigated, strategy, category, priority) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
            );
            for (Risk risk : risks) {
                riskStmt.setString(1, risk.name);
                riskStmt.setDouble(2, risk.probability);
                riskStmt.setDouble(3, risk.impactTime);
                riskStmt.setDouble(4, risk.impactCost);
                riskStmt.setBoolean(5, risk.mitigated);
                riskStmt.setString(6, risk.strategy);
                riskStmt.setString(7, risk.category != null ? risk.category : "Не указано");
                riskStmt.setDouble(8, risk.priority);
                riskStmt.executeUpdate();
            }
            System.out.println("Новые риски сохранены.");

            // Логируем действие с риском
            if (!risks.isEmpty()) {
                logRiskAction(risks.get(risks.size() - 1).name, "Added", "Risk added via AddRiskServlet", localConnection);
            }

            // Проверяем состояние autoCommit перед коммитом
            System.out.println("Состояние autoCommit перед коммитом: " + localConnection.getAutoCommit());

            // Подтверждаем транзакцию
            localConnection.commit();
            System.out.println("Транзакция успешно завершена.");
        } catch (SQLException e) {
            System.err.println("Error uploading to PostgreSQL: " + e.getMessage());
            e.printStackTrace();
            try {
                if (localConnection != null && !localConnection.getAutoCommit()) {
                    localConnection.rollback();
                    System.out.println("Транзакция откатана из-за ошибки.");
                }
            } catch (SQLException rollbackEx) {
                System.err.println("Ошибка при откате транзакции: " + rollbackEx.getMessage());
                rollbackEx.printStackTrace();
            }
        } finally {
            try {
                if (localConnection != null) {
                    // Восстанавливаем исходное состояние autoCommit
                    localConnection.setAutoCommit(autoCommitWasEnabled);
                    System.out.println("Состояние autoCommit восстановлено: " + autoCommitWasEnabled);
                    // Закрываем соединение
                    localConnection.close();
                    System.out.println("Соединение с PostgreSQL закрыто.");
                }
            } catch (SQLException e) {
                System.err.println("Ошибка при восстановлении autoCommit или закрытии соединения: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        ServerManager server = new ServerManager();
        server.startServer();
    }
}]]></Text>
		</JavaClass>
	</JavaClasses>
	<ModelResources>
		<Resource>
			<Path><![CDATA[jetty-all-9.4.31.v20200723-uber.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[gson-2.8.9.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[jetty-servlets-9.4.31.v20200723.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[postgresql-42.6.0.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[httpclient-4.5.14.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[httpcore-4.4.16.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[commons-logging-1.2.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
	</ModelResources>
    <RequiredLibraryReference>
		<LibraryName><![CDATA[com.anylogic.libraries.modules.markup_descriptors]]></LibraryName>
		<VersionMajor>1</VersionMajor>
		<VersionMinor>0</VersionMinor>
		<VersionBuild>0</VersionBuild>
    </RequiredLibraryReference>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[model]]></PackageName>
			<ClassName><![CDATA[gson-2.8.9.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[model]]></PackageName>
			<ClassName><![CDATA[jetty-servlets-9.4.31.v20200723.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[model]]></PackageName>
			<ClassName><![CDATA[jetty-all-9.4.31.v20200723-uber.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[model]]></PackageName>
			<ClassName><![CDATA[postgresql-42.6.0.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[model]]></PackageName>
			<ClassName><![CDATA[httpclient-4.5.14.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[model]]></PackageName>
			<ClassName><![CDATA[httpcore-4.4.16.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[model]]></PackageName>
			<ClassName><![CDATA[commons-logging-1.2.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
</Model>
</AnyLogicWorkspace>